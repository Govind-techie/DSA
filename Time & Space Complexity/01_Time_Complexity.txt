Time Complexity : Time complexity is a measure of the amount of time an algorithm takes to run as a function of the input size, describing its efficiency.

Note : Its not the actual time taken to execute a program.
Note: As the input size of a function increases, the time complexity of it increases.


Example Time Complexity : O(n) 

O(n) means the time taken by the algorithm increases linearly with the size of the input (n). If the input size doubles, the time taken
roughly doubles too.

Example : 

Iterating through an array of size n :


for (int i = 0; i < n; i++) {
    cout << arr[i] << endl;  (One operation per element)
}

Graph of O(n)

The graph of O(n) is a straight line starting from the origin (0, 0), with time growing linearly as input size (n) increases.

Time (Operations)
  ^
  |
10|                                        *
  |                                     *
  |                                  *
  |                               *
  |                            *
  |                         *
  |                      *
  |                   *
  |                *
  |             *
  |          *
  |       *
  |    *
  | *
  +---------------------------------------------------> Input Size (n) (As input size increases graph increases with a linear fashion)
      1    2    3    4    5    6    7    8    9   10

Key Points:
	•	X-axis: Input size (n)
	•	Y-axis: Time (or number of operations)
	•	Slope: Represents the linear growth of time as n increases.


Big O Notation : Big O Notation is a way to describe how the time or space needed for an algorithm grows as the input size increases.
It focuses on the worst-case scenario to measure an algorithm’s efficiency.

Key Points:

	1.	What is "O" in Big O?
	•	"O" stands for "Order of Growth."
	•	It describes how an algorithm's runtime or space usage scales with input size.
	•	Focuses on the dominant factor affecting performance.

	2.	Why Use Big O?
	•	To compare the efficiency of algorithms, especially for large inputs.
	•	It ignores constants and smaller terms, focusing only on the growth rate.

	3.	Common Notations:
	•	O(1): Constant time (fastest, doesn’t depend on input size).
	•	O(log n): Logarithmic time (grows slowly).
	•	O(n): Linear time (grows proportionally with input).
	•	O(n^2): Quadratic time (slows down quickly with large input).

	4.	Example:
	•	If you iterate through an array of size n, the time complexity is O(n) because the number of steps increases linearly with the array size.

Note : Big O helps you understand how an algorithm scales with input size and choose the most efficient solution.